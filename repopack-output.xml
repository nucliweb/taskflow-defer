This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-11-06T01:26:06.691Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repopack, visit: https://github.com/yamadashy/repopack
</additional_info>

</file_summary>

<repository_structure>
demo/
  src/
    App.tsx
    index.css
    main.tsx
    types.ts
    utils.ts
  index.html
  package.json
  postcss.config.js
  tailwind.config.js
  tsconfig.json
  tsconfig.node.json
  vite.config.ts
src/
  types/
    idlefy.d.ts
  index.ts
  types.d.ts
test/
  index.test.ts
  setup.ts
.gitignore
package.json
pnpm-workspace.yaml
tsconfig.json
vercel.json
vite.config.ts
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="demo/src/App.tsx">
import { useState } from "react";
import { Chrome } from "lucide-react";
import { delayTask, delayTaskUntilUrgent } from "taskflow-defer";
import { compute } from "./utils";
import type { OptimizationType } from "./types";

export default function App() {
  const [count, setCount] = useState(0);
  const [optimization, setOptimization] =
    useState<OptimizationType>("nonOptimized");

  const handleCount = async () => {
    setCount((prev) => prev + 1);

    optimization === "delayTask" && (await delayTask());
    optimization === "delayTaskUntilUrgent" && (await delayTaskUntilUrgent());

    compute();
  };

  return (
    <div className="min-h-screen bg-gray-50 py-12 px-4">
      <div className="max-w-2xl mx-auto">
        <div>
          <h1 className="text-4xl font-bold tracking-tight text-gray-900 sm:text-5xl">
            Task Flow Defer Demo
          </h1>

          <div className="mt-10 p-6 bg-white rounded-lg shadow">
            <div className="flex items-center gap-3 text-gray-600 mb-4">
              <Chrome size={30} strokeWidth={1.5} className="flex-shrink-0" />
              <p className="text-sm">
                Open the DevTools, record a{" "}
                <a
                  href="https://developer.chrome.com/docs/devtools/performance"
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-blue-600 hover:text-blue-800 underline"
                >
                  Performance profile
                </a>{" "}
                with CPU 6x slowdown and click the button below.
              </p>
            </div>

            <button
              onClick={handleCount}
              className="w-full py-3 px-4 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-colors"
            >
              Count is {count}
            </button>

            <p className="mt-6 mb-4 text-gray-700">
              Select a method to test different optimization approaches:
            </p>

            <div className="space-y-3">
              <div className="flex items-center">
                <input
                  type="radio"
                  id="nonOptimized"
                  name="optimization"
                  value="nonOptimized"
                  checked={optimization === "nonOptimized"}
                  onChange={(e) =>
                    setOptimization(e.target.value as OptimizationType)
                  }
                  className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300"
                />
                <label
                  htmlFor="nonOptimized"
                  className="ml-3 text-sm text-gray-700"
                >
                  Non-optimized version (blocking computation)
                </label>
              </div>

              <div className="flex items-center">
                <input
                  type="radio"
                  id="delayTask"
                  name="optimization"
                  value="delayTask"
                  checked={optimization === "delayTask"}
                  onChange={(e) =>
                    setOptimization(e.target.value as OptimizationType)
                  }
                  className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300"
                />
                <label
                  htmlFor="delayTask"
                  className="ml-3 text-sm text-gray-700"
                >
                  Use delayTask (delayed computation)
                </label>
              </div>

              <div className="flex items-center">
                <input
                  type="radio"
                  id="delayTaskUntilUrgent"
                  name="optimization"
                  value="delayTaskUntilUrgent"
                  checked={optimization === "delayTaskUntilUrgent"}
                  onChange={(e) =>
                    setOptimization(e.target.value as OptimizationType)
                  }
                  className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300"
                />
                <label
                  htmlFor="delayTaskUntilUrgent"
                  className="ml-3 text-sm text-gray-700"
                >
                  Use delayTaskUntilUrgent (idle-time computation)
                </label>
              </div>
            </div>

            <div className="mt-6 p-4 bg-blue-50 rounded-md">
              <p className="text-sm text-blue-700">
                ðŸ‘‰ Try clicking the button multiple times with each option and
                observe the difference in responsiveness:
              </p>
              <ul className="mt-2 text-sm text-blue-600 list-disc list-inside">
                <li>Non-optimized: UI will freeze during computation</li>
                <li>
                  delayTask: Computation is delayed slightly to allow UI updates
                </li>
                <li>
                  delayTaskUntilUrgent: Computation runs during browser idle
                  time
                </li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="demo/src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  body {
    @apply antialiased;
  }
}
</file>

<file path="demo/src/main.tsx">
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./index.css";

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);
</file>

<file path="demo/src/types.ts">
export type OptimizationType =
  | "nonOptimized"
  | "delayTask"
  | "delayTaskUntilUrgent";
</file>

<file path="demo/src/utils.ts">
/**
 * Simulates a heavy computation task
 * This is used to demonstrate the performance impact
 */
export function compute(): void {
  const end = Date.now() + 500; // Simulate 500ms of heavy computation
  while (Date.now() < end) {
    // Blocking operation
  }
}
</file>

<file path="demo/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Taskflow Defer Demo</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="demo/package.json">
{
  "name": "demo",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "lint": "eslint src --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "lucide-react": "^0.263.1",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "taskflow-defer": "workspace:^"
  },
  "devDependencies": {
    "@tailwindcss/forms": "^0.5.9",
    "@types/react": "^18.2.15",
    "@types/react-dom": "^18.2.7",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "@vitejs/plugin-react": "^4.0.3",
    "autoprefixer": "^10.4.14",
    "postcss": "^8.4.27",
    "tailwindcss": "^3.3.3",
    "typescript": "^5.0.2",
    "vite": "^4.4.5"
  }
}
</file>

<file path="demo/postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="demo/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],
  theme: {
    extend: {},
  },
  plugins: [require("@tailwindcss/forms")],
};
</file>

<file path="demo/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "taskflow-defer": ["../src/index.ts"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="demo/tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="demo/vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import { resolve } from "path";

export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
    open: true,
    host: true,
  },
  resolve: {
    alias: {
      "taskflow-defer": resolve(__dirname, "../src/index.ts"),
    },
  },
});
</file>

<file path="src/types/idlefy.d.ts">
// src/types/idlefy.d.ts
declare module "idlefy" {
  export interface IdleQueueOptions {
    ensureTasksRun?: boolean;
    timeout?: number;
  }

  export type Task = (state: "idle" | "running" | "completed") => void;

  export class IdleQueue {
    constructor(options?: IdleQueueOptions);
    pushTask(task: Task, options?: IdleQueueOptions): void;
  }
}

export {};
</file>

<file path="src/index.ts">
import { IdleQueue } from "idlefy";

/**
 * Delays a task execution using setTimeout and requestAnimationFrame
 * @returns Promise that resolves when the task should be executed
 */
export function delayTask(): Promise<void> {
  return new Promise<void>((resolve) => {
    setTimeout(resolve, 100);
    requestAnimationFrame(() => {
      setTimeout(resolve, 0);
    });
  });
}

/**
 * Delays a task until the browser is no longer busy
 * @param options - Configuration options for the IdleQueue
 * @returns Promise that resolves when the task should be executed
 */
export function delayTaskUntilUrgent(options?: {
  ensureTasksRun?: boolean;
  timeout?: number;
}): Promise<void> {
  const queue = new IdleQueue({ ensureTasksRun: true, ...options });

  return new Promise<void>((resolve) => {
    const task = () => {
      resolve();
    };
    queue.pushTask(task);
  });
}
</file>

<file path="src/types.d.ts">
declare module "idlefy" {
  interface IdleQueueOptions {
    ensureTasksRun?: boolean;
    timeout?: number;
  }

  type Task = (state: "idle" | "running" | "completed") => void;

  class IdleQueue {
    constructor(options?: IdleQueueOptions);
    pushTask(task: Task, options?: IdleQueueOptions): void;
  }
}
</file>

<file path="test/index.test.ts">
import { describe, it, expect, vi } from "vitest";
import { delayTask, delayTaskUntilUrgent } from "../src";

describe("delayTask", () => {
  it("should execute function", async () => {
    const callback = vi.fn();

    // Mock timeouts and RAF for faster tests
    vi.useFakeTimers();

    const promise = delayTask().then(callback);

    // Avanzar los timers de manera controlada
    vi.advanceTimersByTime(100);
    await vi.runAllTimersAsync();

    await promise;

    expect(callback).toHaveBeenCalled();

    // Restaurar timers reales
    vi.useRealTimers();
  });
});

describe("delayTaskUntilUrgent", () => {
  it("should execute function", async () => {
    const callback = vi.fn();

    vi.useFakeTimers();

    const promise = delayTaskUntilUrgent().then(callback);

    await vi.runAllTimersAsync();

    await promise;

    expect(callback).toHaveBeenCalled();

    vi.useRealTimers();
  });
});
</file>

<file path="test/setup.ts">
import { afterEach, vi } from "vitest";
</file>

<file path=".gitignore">
# Dependencies
node_modules
.pnpm-store

# Production
dist
demo/dist

# Testing
coverage

# Misc
.DS_Store
*.pem
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# Vercel
.vercel
</file>

<file path="package.json">
{
  "name": "taskflow-defer",
  "version": "1.0.0",
  "type": "module",
  "files": [
    "dist"
  ],
  "main": "./dist/index.cjs",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js",
      "require": "./dist/index.cjs"
    }
  },
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "test": "vitest",
    "test:coverage": "vitest run --coverage",
    "lint": "eslint . --ext .ts",
    "format": "prettier --write .",
    "demo": "pnpm --filter demo dev",
    "demo:build": "pnpm --filter demo build"
  },
  "dependencies": {
    "idlefy": "1.1.1",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "@vitejs/plugin-react": "^4.0.3",
    "@vitest/coverage-v8": "^1.0.0",
    "demo": "^0.1.10",
    "eslint": "^8.0.0",
    "happy-dom": "^12.0.0",
    "prettier": "^3.0.0",
    "typescript": "^5.0.0",
    "vite": "^5.0.0",
    "vite-plugin-dts": "^3.0.0",
    "vitest": "^1.0.0"
  }
}
</file>

<file path="pnpm-workspace.yaml">
packages:
  - "demo"
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": false,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "declaration": true,
    "declarationDir": "dist",
    "outDir": "dist",
    "skipLibCheck": true,
    "allowImportingTsExtensions": false,
    "jsx": "preserve",
    "types": ["./src/types.d.ts"]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "demo"]
}
</file>

<file path="vercel.json">
{
  "buildCommand": "pnpm build",
  "installCommand": "pnpm install",
  "outputDirectory": "demo/dist"
}
</file>

<file path="vite.config.ts">
import { defineConfig } from "vite";
import dts from "vite-plugin-dts";
import { resolve } from "path";

export default defineConfig({
  build: {
    lib: {
      entry: resolve(__dirname, "src/index.ts"),
      name: "performance",
      fileName: "index",
      formats: ["es", "cjs"],
    },
    rollupOptions: {
      external: ["idlefy"],
      output: {
        globals: {
          idlefy: "idlefy",
        },
      },
    },
  },
  plugins: [dts()],
  test: {
    environment: "happy-dom",
    // Alternatively: environment: 'jsdom',
    setupFiles: ["./test/setup.ts"],
    coverage: {
      provider: "v8",
      reporter: ["text", "json", "html"],
    },
    globals: true,
  },
});
</file>

</repository_files>
